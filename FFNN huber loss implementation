import numpy as np

def huber_loss(y_true, y_pred, delta=1.0):
    error = y_true - y_pred
    abs_error = np.abs(error)

    quadratic = np.minimum(abs_error, delta)
    linear = abs_error - quadratic

    loss = 0.5 * quadratic**2 + delta * linear
    return np.mean(loss)

class SimpleFFNN:
    def __init__(self, input_size, hidden_size, output_size):
        self.W1 = np.random.randn(input_size, hidden_size)
        self.b1 = np.zeros((1, hidden_size))
        self.W2 = np.random.randn(hidden_size, output_size)
        self.b2 = np.zeros((1, output_size))

    def relu(self, x):
        return np.maximum(0, x)

    def forward(self, X):
        self.z1 = np.dot(X, self.W1) + self.b1
        self.a1 = self.relu(self.z1)
        self.z2 = np.dot(self.a1, self.W2) + self.b2
        return self.z2

# Input (3 features)
X = np.array([[5, 8, 3]])          # shape (1, 3)

# Desired output (3 predicted values)
y_true = np.array([[5.7, 7.8, 3.4]])  # shape (1, 3)

# Network with 3 outputs
model = SimpleFFNN(input_size=3, hidden_size=5, output_size=3)

# Forward pass
y_pred = model.forward(X)

# Compute Huber loss
loss = huber_loss(y_true, y_pred)

print("Predicted Values:", y_pred)
print("Huber Loss:", loss)
